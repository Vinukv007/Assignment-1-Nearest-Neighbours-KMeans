# -*- coding: utf-8 -*-
"""Assignment 1: Nearest Neighbours & KMeans.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1TCuJPSCTSuEtcSP-cVLZa6xpHLRvlm7m
"""

import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt

# Predicting Price of House using KNearestNeighbour Regressor

"""Use pandas to get some insights into the data """

df=pd.read_csv('https://raw.githubusercontent.com/edyoda/data-science-complete-tutorial/master/Data/house_rental_data.csv.txt')
df.head()

df.drop('Unnamed: 0',axis=1,inplace=True)

df.drop_duplicates(inplace=True)

a=df.corr()
a

a[a['Price']>0.4]

df.describe()

df.info()

df.dtypes

df.isna().sum()

"""### Show some interesting visualization of the data"""

sns.scatterplot(df['Floor'],df['Price'])

sns.scatterplot(df['Living.Room'],df['Price'])

sns.scatterplot(df['Sqft'],df['Price'])

sns.scatterplot(df['Bedroom'],df['Price'])

sns.scatterplot(df['Bathroom'],df['Price'])

sns.distplot(df['Bedroom'],kde=False)

"""### Manage data for training & testing"""

x=df[['Sqft','Bedroom','Bathroom']]

from sklearn.preprocessing import MinMaxScaler
mms=MinMaxScaler()
x_fit=mms.fit_transform(x)
y=df.Price

from sklearn.model_selection import train_test_split

xtrain,xtest, ytrain,ytest=train_test_split(x_fit,y,test_size=0.2,random_state=0)

from sklearn.neighbors import KNeighborsRegressor

score={}
for i in range(3,10,2):
  knr=KNeighborsRegressor(n_neighbors=i)
  knr.fit(xtrain,ytrain)
  score[i]=knr.score(xtest,ytest)
score

keymax = max(score, key= lambda x: score[x])

k=keymax

knr=KNeighborsRegressor(n_neighbors=k)
knr.fit(xtrain,ytrain)
knr.score(xtest,ytest)

knr.get_params()

# Cluster similar Houses

df.isna().sum()

df.dtypes

df.drop(['Floor','TotalFloor'],axis=1,inplace=True)

for i in df.columns:
  print(set(list(df[i])),'\n')

sns.boxplot(df['Sqft'])

df[df['Sqft']>5000]

sns.boxplot(df['Price'])



df[df['Price']>200000]

from sklearn.cluster import KMeans

error=[]
for k in range(1,11):
  kmeans=KMeans(n_clusters=k)
  kmeans.fit(df)
  error.append(kmeans.inertia_)

plt.plot([i for i in range(1,11)],error)

k=3

kmeans=KMeans(n_clusters=k)
kmeans.fit(df)

df['cluster']=kmeans.predict(df)
df.head()

